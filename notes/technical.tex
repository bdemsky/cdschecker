\section{Technical}\label{sec:technical}

\subsection{Inference Rules}
Previous work takes advantage of model-checking approach to check whether a
specific C/C++11 trace is sequentially consistent. By building up edges
(\textit{sb}, \textit{rf} and \textit{sc} by implication rules) between atomic
operations, it judges whether the trace is SC by whether there exists a cycle in
that graph. Besides, when it finds a non-SC trace, it has a sorting algorithm
that generates an SC-like trace and exposes which reads-from edge that causes a
cycle.

Under the C/C++11 memory model, inferring the ordering parameters to obtain SC
behaviors is essentially a searching problem. In the absence of consume
operations, memory order parameters for atomic operations can be only one of the
following: \textit{memory\_order\_relaxed}, \textit{memory\_order\_release},
\textit{memory\_order\_acquire}, \textit{memory\_order\_acq\_rel} and
\textit{memory\_order\_seq\_cst}. By enumerating all possible memory order
parameters, we can guarantee that we can find out all the possible inference of
parameters that ensure SC behaviors for a specific test case. However, this
naive approach obviously leads to an exponential searching space.

Actually, when we have a non-SC execution, we have some knowledge availabe
reflecting where the problem may lie. Consider we start from the case where all
memory order parameters are \textit{memory\_order\_relaxed}. Whenever the
model-checking approach finds out a cycle in a specific execution, we have to
infer some stronger memory orders to eliminate the cycle. What causes the cycle
to happen leads to the non-SC trace. We propose a search-based approach combined
with cycle patterns and their fixes to reduce searching space.

In Figure~\ref{fig:fence_implications} , we show a number of universal patterns
that can exist in cycles. We explain how we should fix those cycle patterns
respectivelys the following.

\mypara{\bf Circular \textit{sb} $\cup$ \textit{rf}:} If a cycle is composed of
edges which are the union of \textit{sb} \& \textit{rf}, a universal fix is to
make all but one of the atomic operation \textit{happen-before} the next atomic
operation in that cycle. It is worth noting that imposing
\textit{happens-before} to ajacent nodes is not limited to imposing
release/acquire pairs to store/load operations involed in the cycle. Instead,
any possible paths composed with the union of \textit{sb} $\cup$ \textit{rf}
between the two nodes can be strengthened.

\mypara{\bf Old value read \RNum{1}:} 


\mypara{\bf Old value read \RNum{2}:}


\mypara{\bf Future value read:}


Figure~\ref{fig:algorithm} shows the core searching algorithm for all possible
parameters.

\begin{figure}[!ht]
\centering
\begin{tabular}{c}
\multicolumn{1}{c}{Circular \textit{sb} \& \textit{rf}}\\
\includegraphics[scale=.45]{figures/circular_sb_rf}\\
\multicolumn{1}{c}{Old Value Read \RNum{1}}\\
\includegraphics[scale=.45]{figures/old_val_sync}\\
\multicolumn{1}{c}{Old Value Read \RNum{2}}\\
\includegraphics[scale=.45]{figures/old_val_isc}\\
\multicolumn{1}{c}{Future Value Read}\\
\includegraphics[scale=.45]{figures/future_val_isc}\\
\end{tabular}
\caption{\label{fig:fence_implications}Cycle Patterns for Non-SC Behaviors}
\end{figure}


\begin{figure}[!htbp]
\begin{algorithmic}[1]
\Function{InferParams}{}
\State candidates := \{\}
\State candidate $c1$ := replace all wildcards with \textit{relaxed}
\State candidates += $c1$
\State results := \{\}
\While{candidates is not empty}
\State Candidate $c$ := candidates.pop()
\State Model-check with $c$ and yield a cycle $l$
\If{$l$ == NULL}
\State results += $c$
\Else
\State \Call {StrengthenParam}{$l$, $c$, candidates}
\EndIf
\EndWhile
\State \Return{results}
\EndFunction

\Procedure{StrengthenParam}{c, p, candidates}
\While{$\exists$ a pattern $p$ in cycle $c$}
\State possible\_fixes := strengthen $c$ by pattern $p$
\State candidates += possible\_fixes 
\EndWhile
\EndProcedure

\end{algorithmic}
\caption{\label{fig:algorithm}Algorithm for Searching All Possible Parameters}
\end{figure}

