\section{Example}
\label{sec:example}

To demonstrate how concurrent data structures are implemented with C/C++ atomic
primitives, we provide the example shown in Figure~\ref{fig:example}. This
scenario assumes a producer thread to update a shared variable \code{data} and a
consumer thread to read the updated \code{data}. It uses an shared boolean
variable \code{flag} to synchronize between the two threads, and provides
\code{write\_publish()} and \code{read\_prepare()} as the interfaces.

\begin{figure}[h]
\begin{lstlisting}
atomic<bool> flag(false);
atomic<int> data(0); // Shared variables

write_publish() {
	flag.store(true, memory_order_release);/*@ \label{line:flag_store} @*/
}

read_prepare() {
	while(!flag.load(memory_order_acquire) ;/*@ \label{line:flag_load} @*/
}

// In thread 1/*@ \label{line:testcase_begin} @*/
void producer() {
	data.store(1, memory_order_relaxed);
	write_publish();
}

// In thread2
void consumer() {
	read_prepare();
	int r1 = data.load(memory_order_relaxed);
}/*@ \label{line:testcase_end} @*/
\end{lstlisting}
\caption{\label{fig:example}C++11 Lock Example}
\end{figure}

\begin{figure}[t]
        \centering
	\includegraphics[scale=0.34]{figures/lockhistory}
		\caption{\label{fig:lockhistory} History of a possible execution of Lock}
\end{figure}

In our example, the Lock data structure is very similar to a spinning lock. To
be more specific, its implementation is non-blocking because it only use
low-level lock-free atomic operations. To be more specific, when a thread calls
\code{lock()}, it first loads flag. If it sees a true flag, meaning that another
thread is holding the lock and it should continue trying; otherwise, it tries to
grab the lock with a \code{compare\_exchange\_strong} operation, meaning that
all threads waiting for the lock are racing for the lock and only one of them
end up successfully holding the lock. Those threads failing to grab the lock
should repeatedly try the whole procedure until they succeed. For
\code{unlock()}, it has a simpler logic. Since no thread but the thread holding
the lock should race for \code{unlock()}, what the thread should do is the store
false to \code{flag}.

We then explain that such a data structure is correct under our correctness
model. Assume we have a test case with two threads as shown in
Figure~\ref{fig:lockexample} from Line~\ref{line:testcase_begin} to
Line~\ref{line:testcase_end}. Thread 1 just grabs the lock and does something,
while thread 2 grabs the lock and does something else, and then releases the lock.
The history of one possible execution trace is shown in
Figure~\ref{fig:lockhistory}. In the history , we can see that though thread
1 invokes \code{lock()} earlier than thread 2 does, it does not grab the
lock until thread 2 grabs the lock, does something else, and releases the lock.
According to the rule of our correctness model, we can reorder the first lock
invocation event of thread 1 as shown to yield a reordered history. It is
obvious that the reordered history is similar to the following events
happening sequentially: thread2 grabs the lock, thread2 releases the lock, and
thread1 grabs the lock.

Besides, the synchronization requirement as shown in
Figure~\ref{fig:lockhistory} is that an \code{unlock()} should {\it interface
happens-before} the next successful \code{lock()}. To explain this, we consider
Line~\ref{line:lockacquire} and Line~\ref{line:unlock} in
Figure~\ref{fig:lockexample}. Since every time a \code{unlock()} finishes, a
store to \code{flag} with released semantics is executed, and the next successful \code{lock()}
must load from \code{flag} with acquired semantics. According to C/C++ memory
model, the two operations synchronize with each other. Since operations before
\code{unlock()} is sequenced-before the store, and \code{lock()} is
sequenced-before the load, operations before the \code{unlock()} synchronizes
with operations after the \code{lock()}, meaning that \code{unlock()} {\it
interface happens-before} \code{lock()}.

One thing worth noting is that we can also identify the linearization points of
the two interface call. First, since \code{unlock()} has only one line, it is
obvious that when Line~\ref{line:unlock} is successfully executed, the lock is
available to all threads, meaning that the unlock effects are visible to other
threads. Second, according to the logic explained above, the point when
\code{lock()} successfully grabs the lock is when it successfully executes the
\code{compare\_exchange\_strong} operation in Line~\ref{line:CAS}, meaning that
the variable \code{succ} should be true.

The above explains that the Lock example is correct according to our correctness
model. This gives us an idea how we can express the correctness specification of
linearizable data structures, and we discuss it with details in
Section~\ref{sec:specification}.

